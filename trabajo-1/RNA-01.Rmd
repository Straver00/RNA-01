---
title: "Optimizaci√≥n Num√©rica y Combinatoria"
author:
  - Carlos Jose Quijano Valencia
  -
  -
  -
  -
date: "`r Sys.Date()`"
output: html_document
---

# Tabla de contenidos

1.  [Parte 1: Optimizaci√≥n Num√©rica](#parte-1-optimizaci√≥n-num√©rica)
    -   [Funciones de prueba](#funciones-de-prueba)
    -   [Optimizaci√≥n en dos y tres dimensiones](#optimizaci√≥n-en-dos-y-tres-dimensiones)
    -   [M√©todos heur√≠sticos vs M√©todos de descenso por gradiente](#m√©todos-heur√≠sticos-vs-m√©todos-de-descenso-por-gradiente)
    -   [Representaci√≥n gr√°fica del proceso de optimizaci√≥n](#representaci√≥n-gr√°fica-del-proceso-de-optimizacion)
2.  [Parte 2: Optimizaci√≥n Combinatoria](#parte-2-optimizaci√≥n-combinatoria)
    -   [Descripci√≥n del problema del vendedor](#descripci√≥n-del-problema-del-vendedor)
    -   [Algoritmos utilizados](#algoritmos-utilizados)
    -   [Representaci√≥n gr√°fica de la mejor soluci√≥n](#representaci√≥n-gr√°fica-de-la-mejor-soluci√≥n)
3.  [Reporte de Contribuci√≥n Individual](#reporte-de-contribuci√≥n-individual)
4.  [Bibliograf√≠a](#bibliograf√≠a) {#bibliograf√≠a}

# Parte 1: Optimizaci√≥n Num√©rica {#parte-1-optimizaci√≥n-num√©rica}

(Agregar contenido de la Parte 1 aqu√≠)

------------------------------------------------------------------------

# Parte 2: Optimizaci√≥n Combinatoria {#parte-2-optimizaci√≥n-combinatoria}

En esta secci√≥n, se aborda la optimizaci√≥n del recorrido de un vendedor que debe visitar 13 ciudades principales de Colombia: Bogot√°, Cali, Medell√≠n, Barranquilla, Cartagena, C√∫cuta, Bucaramanga, Pereira, Santa Marta, Ibagu√©, Pasto, Manizales y Neiva. El objetivo central es determinar la ruta que minimice el costo total del viaje, empleando dos metaheur√≠sticas: Optimizaci√≥n por **Colonias de Hormigas (ACO)** y **Algoritmos Gen√©ticos (GA)**. El costo total considera factores como el salario del conductor durante el viaje, el consumo de combustible, las distancias, tiempos de viaje y peajes.

## Descripci√≥n del problema del vendedor {#descripci√≥n-del-problema-del-vendedor}

El problema se modela como una instancia del Problema del Viajante de Comercio (TSP), un cl√°sico desaf√≠o de optimizaci√≥n combinatoria. Se busca encontrar la ruta c√≠clica m√°s econ√≥mica que visite cada una de las 13 ciudades exactamente una vez y regrese a la ciudad de origen. El costo asociado al desplazamiento entre cualquier par de ciudades se desglosa en tres componentes principales:

-   **Costo del salario** : Se tom√≥ como referencia el salario m√≠nimo mensual legal vigente (SMMLV) en Colombia al momento del estudio, fijado en \$1,423,500 COP (fuente: Ministerio de Trabajo). Haciendo calculos simples llegamos a que la hora ordinaria en Colombia se da por la siguiente formula:

    $$
    \text{Valor hora ordinaria} = \frac{\text{salario mensual}}{\left(\frac{\text{horas semanales}}{6} \times 30\right)}
    $$

    Las horas semanales en Colombia a fecha de la realizaci√≥n de este trabajo es de 46, reemplazando en la ecuaci√≥n:

    $$
    \text{Valor hora ordinaria} = \frac{$1.423.500}{\left(\frac{46}{6} \times 30\right)}
    $$

    Lo cual nos da un valor de hora ordinaria de \$6.189, el cual usaremos para el calculo del costo del salario.

    Adicionalmente necesitamos el tiempo de conducci√≥n entre ciudades para poder calcular el costo del salario. Para esto, se consultaron en [Google Maps Distance Matrix API](https://developers.google.com/maps/documentation/distance-matrix){target="_blank"} utilizando el modo *dirving*.

    El costo del salario se calcula con la siguiente ecuaci√≥n (1):

    $\text{Costo_salario} = \text{tiempo} \times \text{costo_hora} \tag{1}$

-   **Costo del combustible** . Se utiliz√≥ un precio promedio del gal√≥n de gasolina, obtenido a partir de los precios reportados por la Comisi√≥n de Regulaci√≥n de Energ√≠a y Gas (CREG) para las 13 ciudades principales en la fecha del an√°lisis, resultando en \$15,827 COP/gal√≥n.

    Se seleccion√≥ como veh√≠culo de referencia un Kia Picanto 1.0L. Seg√∫n datos de la publicaci√≥n especializada "El Carro Colombiano", este veh√≠culo presenta un consumo mixto aproximado de 60 km/gal√≥n.

    Adem√°s necesitamos la distancia entre las ciudades, la cual fue obtenida de la misma API de Google Maps. La distancia entre las ciudades se obtiene en kil√≥metros y se usa para calcular el costo del combustible.

    El costo del combustible se calcula con la siguiente ecuaci√≥n (2):

    $$
    \text{Costo_gasolina} = \left( \frac{\text{Distancia}}{\text{Rendimiento (km/galon)}} \right) \times \text{Precio_por_galon} \tag{2}
    $$

    Observaci√≥n: Se uso el galon como unidad de medida ya que en Colombia es el estandar para medir la gasolina.

-   **Costo de peajes**. La informaci√≥n sobre los costos de peajes para las rutas que conectan las 13 ciudades se obtuvo de la plataforma Tollguru (Se consideraron los peajes de las rutas m√°s comunes).

    El costo de los peajes se calcula con la siguiente ecuaci√≥n (3):

    $$
    \text{Costo_peaje} = \text{peaje} \tag{3}
    $$

La suma de todos estos costos nos da el costo total de desplazamiento entre dos ciudades, que se calcula con la siguiente ecuaci√≥n (4): $$
\text{Costo_total} = \text{Costo_salario} + \text{Costo_gasolina} + \text{Costo_peaje} \tag{4}
$$ Este problema se modela como un **Problema del Viajante de Comercio** (TSP, por sus siglas en ingl√©s), en el cual buscamos la ruta m√°s corta o econ√≥mica para visitar todas las ciudades.

## Algoritmos utilizados {#algoritmos-utilizados}

En este caso, se usan dos algoritmos de optimizaci√≥n para encontrar la mejor ruta:

1\. **Algoritmo de Colonias de Hormigas (ACO)**: Este algoritmo se inspira en el comportamiento colectivo de las hormigas al buscar caminos. Emplea feromonas artificiales para marcar las rutas: las rutas m√°s cortas (de menor costo) acumulan m√°s feromona, incrementando la probabilidad de que sean elegidas por hormigas futuras, guiando as√≠ la b√∫squeda hacia soluciones prometedoras.

2\. **Algoritmo Gen√©tico (GA)**: Basado en los principios de la evoluci√≥n biol√≥gica y la selecci√≥n natural, este algoritmo opera sobre una poblaci√≥n de posibles rutas (cromosomas). Mediante operadores como la selecci√≥n (favoreciendo las rutas de menor costo), el cruce (combinando partes de rutas existentes para crear nuevas) y la mutaci√≥n (introduciendo peque√±as alteraciones aleatorias), la poblaci√≥n evoluciona a lo largo de generaciones, convergiendo hacia soluciones de alta calidad.

### C√≥digo en R para la optimizaci√≥n

Cargamos las librerias necesarias:

```{r}
library(stats)
library(ggplot2)
library(dplyr)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(gganimate)
library(gifski)
library(GA)
library(httr)
library(jsonlite)
library(dplyr)
library(tibble)
library(readr)
```

Consultamos las distancias viales entre las ciudades y tiempos de viaje ofrecidos por la API de Google. Adicionalmente cargamos los costos de peajes, los nombres de las ciudades y el n√∫mero de ciudades:

```{r}
# Consultamos las distancias viales y tiempos de viaje
API_KEY <- "APIKEY DE GOOGLE MAPS"

addresses <- c(
  "Bogota, Colombia", "Cali, Colombia", "Medellin, Colombia", "Barranquilla, Colombia",
  "Cartagena, Colombia", "Cucuta, Colombia", "Bucaramanga, Colombia", "Pereira, Colombia",
  "Santa Marta, Colombia", "Ibague, Colombia", "Pasto, Colombia", "Manizales, Colombia",
  "Neiva, Colombia"
)

city_names <- sub(",.*$", "", addresses)


get_distance_time_matrix <- function(addr_vec, labels, api_key) {
  n <- length(addr_vec)
  dist_mat <- matrix(NA_real_, n, n)
  time_mat <- matrix(NA_real_, n, n)
  
  for (i in seq_along(addr_vec)) {
    res <- httr::GET(
      "https://maps.googleapis.com/maps/api/distancematrix/json",
      query = list(
        origins      = addr_vec[i],
        destinations = paste(addr_vec, collapse = "|"),
        key          = api_key,
        mode         = "driving",
        language     = "es",
        units        = "metric"
      )
    )
    httr::stop_for_status(res)
    
    # üëá  ¬°OJO!  simplifyVector = FALSE mantiene la jerarqu√≠a original
    json <- fromJSON(content(res, "text", encoding = "UTF-8"),
                     simplifyVector = FALSE)
    
    if (json$status != "OK") {
      stop("API error: ", json$error_message)
    }
    
    elements <- json$rows[[1]]$elements   # ahora s√≠ es lista de 13 sub-listas
    
    # Recorremos destino por destino
    for (j in seq_along(elements)) {
      el <- elements[[j]]
      if (el$status == "OK") {
        dist_mat[i, j] <- el$distance$value / 1000
        time_mat[i, j] <- el$duration$value / 3600
      }
    }
    
    Sys.sleep(1)
  }
  
  dist_df <- as_tibble(dist_mat, .name_repair = ~labels) |> 
             add_column(Ciudad = labels, .before = 1)
  time_df <- as_tibble(time_mat, .name_repair = ~labels) |> 
             add_column(Ciudad = labels, .before = 1)
  dist_df <- as.data.frame(dist_mat)
  time_df <- as.data.frame(time_mat)

  rownames(dist_df) <- labels
  rownames(time_df) <- labels
  colnames(dist_df) <- labels
  colnames(time_df) <- labels
  list(distances = dist_df, times = time_df)
}

matrices <- get_distance_time_matrix(addresses, city_names, API_KEY)
df_distancias  <- matrices$distances
df_tiempos_viajes  <- matrices$times

# Guardar a CSV
write_csv(df_distancias,  "df_distancias.csv")
write_csv(df_tiempos_viajes,  "df_tiempos_viajes.csv")


df_peajes <- read.csv("df_peajes.csv", row.names = 1)
ciudades_nombres <- c("Bogota", "Cali", "Medellin", "Barranquilla", "Cartagena", 
                      "Cucuta", "Bucaramanga", "Pereira", "Santa Marta", "Ibague", 
                      "Pasto", "Manizales", "Neiva")
n_ciudades <- length(ciudades_nombres)
```

Agregamos datos necesarios para graficar la ruta:

```{r}
coords <- data.frame(
  ciudad = ciudades_nombres,
  lon = c(-74.0721, -76.5225, -75.5736, -74.7964, -75.5144, -72.5074, -73.1198, -75.6961, -74.2050, -75.2174, -77.2811, -75.4849, -75.2819),
  lat = c(4.7110, 3.4372, 6.2442, 10.9639, 10.3910, 7.8939, 7.1139, 4.8133, 11.2404, 4.4389, 1.2136, 5.0689, 2.9273)
)

colombia <- ne_countries(scale = "medium", country = "Colombia", returnclass = "sf")
```

Definimos par√°metros de costos iniciales para el salario, consumo de combustible y precio de gasolina:

```{r}
salario_hora <- 6189  # COP/hora
consumo_combustible <- 60  # km/gal√≥n
precio_gasolina <- 15827  # COP/gal√≥n
```

Calculamos el costo de la gasolina, el tiempo de los viajes y el costo del salario:

```{r}
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes * salario_hora
```

Ahora calculamos el costo total de desplazamiento entre las ciudades:

```{r}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("df_costo_total.csv")) {
  file.remove("df_costo_total.csv")
  write.csv(df_costo_total, "df_costo_total.csv")
} else {
  write.csv(df_costo_total, "df_costo_total.csv")
}
```

Ahora, dado este dataset de costos utilizaremos tanto el algoritmo de colonia de hormigas y un algoritmo evolutivo para encontrar el orden correcto.

## Algoritmo de Optimizaci√≥n por Colonia de Hormigas (ACO)

La Optimizaci√≥n por Colonia de Hormigas (ACO) es "una t√©cnica probabil√≠stica para solucionar problemas computacionales que pueden reducirse a buscar los mejores caminos o rutas en grafos", como se describe en la literatura (Wikipedia, s.f.). Su funcionamiento se inspira directamente en c√≥mo las hormigas encuentran eficientemente fuentes de alimento: depositan feromonas en sus trayectos, y las rutas m√°s efectivas acumulan mayores concentraciones de esta sustancia, atrayendo a m√°s hormigas.

El algoritmo ACO simula este comportamiento mediante:

**Hormigas Artificiales:** Agentes que construyen soluciones candidatas (rutas).

**Feromonas Virtuales:** Informaci√≥n asociada a los componentes de la soluci√≥n (e.g., las conexiones entre ciudades) que se actualiza seg√∫n la calidad de las soluciones encontradas. Rutas de mejor calidad refuerzan m√°s intensamente sus componentes.

**Selecci√≥n Probabil√≠stica:** Las hormigas eligen los siguientes pasos bas√°ndose tanto en la intensidad de la feromona como, opcionalmente, en informaci√≥n heur√≠stica (e.g., la distancia directa), favoreciendo caminos prometedores pero permitiendo la exploraci√≥n.

A continuaci√≥n, se presenta la funci√≥n `ant_colony_optimization_r_con_historial` desarrollada en R para implementar el algoritmo de optimizaci√≥n por colonia de hormigas. Esta funci√≥n est√° dise√±ada para resolver el Problema del Viajante de Comercio (TSP), buscando la ruta de menor costo total. Adem√°s de encontrar la mejor ruta, registra el historial de la mejor soluci√≥n encontrada en cada iteraci√≥n, lo cual es √∫til para analizar la convergencia y visualizar el proceso.

```{r}
# --- Funci√≥n ACO √önica (con historial detallado de rutas) ---
# Nota: Esta funci√≥n devuelve tanto el resultado final como el historial.
ant_colony_optimization_r_con_historial <- function(costos, num_ants = 10, num_iterations = 100, alpha = 1.0, beta = 2.0, rho = 0.5, Q = 100, verbose = TRUE) {

  # Convertir a matriz y validar
  cost_matrix <- as.matrix(costos)
  n_nodes <- ncol(cost_matrix)
  if (nrow(cost_matrix) != n_nodes) stop("La matriz de costos debe ser cuadrada.")

  # Calcular visibilidad (eta)
  visibility_matrix <- cost_matrix
  diag(visibility_matrix) <- Inf # No viajar de un nodo a s√≠ mismo
  eta <- 1 / visibility_matrix
  eta[is.infinite(eta)] <- 0 # Manejar divisi√≥n por cero o Inf si el costo era 0 o Inf
  eta[visibility_matrix == 0] <- 0 # Asegurar que costo 0 no de visibilidad infinita

  # Inicializar feromona
  mean_cost <- mean(cost_matrix[cost_matrix > 0 & !is.infinite(cost_matrix)], na.rm = TRUE)
  initial_pheromone <- if (is.na(mean_cost) || mean_cost <= 0 || !is.finite(mean_cost)) 1.0 else 1 / (n_nodes * mean_cost)
  pheromone_matrix <- matrix(initial_pheromone, nrow = n_nodes, ncol = n_nodes)
  diag(pheromone_matrix) <- 0 # Sin feromona en el propio nodo

  # Variables para guardar la mejor soluci√≥n encontrada
  best_tour <- NULL
  best_length <- Inf

  # Estructuras para el historial
  history_best_length <- numeric(num_iterations) # Guarda el mejor costo hasta esa iteraci√≥n
  history_best_tours <- vector("list", num_iterations) # Guarda la mejor ruta hasta esa iteraci√≥n

  # --- Bucle principal de iteraciones ---
  for (iter in 1:num_iterations) {
    all_tours <- vector("list", num_ants) # Rutas de todas las hormigas en esta iteraci√≥n
    all_lengths <- numeric(num_ants)      # Costos de todas las rutas en esta iteraci√≥n
    iter_found_new_best <- FALSE           # Flag para indicar si se mejor√≥ en esta iteraci√≥n

    # --- Bucle de hormigas ---
    for (ant in 1:num_ants) {
      current_tour <- numeric(n_nodes) # Ruta de la hormiga actual
      visited <- logical(n_nodes)      # Nodos visitados por la hormiga actual

      # Empezar en un nodo aleatorio
      start_node <- sample(1:n_nodes, 1)
      current_tour[1] <- start_node
      visited[start_node] <- TRUE
      current_node <- start_node

      # --- Construcci√≥n de la ruta de la hormiga ---
      for (step in 2:n_nodes) {
        possible_nodes <- which(!visited) # Nodos a√∫n no visitados

        if (length(possible_nodes) == 0) break # Si no hay m√°s nodos, terminar (raro en TSP)

        # Obtener feromonas y visibilidad hacia los nodos posibles
        pheromones_to_possible <- pheromone_matrix[current_node, possible_nodes]
        eta_to_possible <- eta[current_node, possible_nodes]

        # Manejar valores no finitos o muy peque√±os para evitar NaN/Inf en probabilidades
        pheromones_to_possible[!is.finite(pheromones_to_possible)] <- 1e-10
        eta_to_possible[!is.finite(eta_to_possible)] <- 1e-10
        pheromones_to_possible[pheromones_to_possible < 1e-10] <- 1e-10
        eta_to_possible[eta_to_possible < 1e-10] <- 1e-10

        # Calcular numerador de la probabilidad de transici√≥n
        prob_numerator <- (pheromones_to_possible^alpha) * (eta_to_possible^beta)
        sum_prob <- sum(prob_numerator)

        # Calcular probabilidades finales
        probabilities <- if (sum_prob > 1e-10 && is.finite(sum_prob)) {
          prob_numerator / sum_prob
        } else {
          # Si suma es cero o no finita, asignar probabilidad uniforme
          rep(1 / length(possible_nodes), length(possible_nodes))
        }

        # Asegurar que las probabilidades sumen 1 (manejo de errores num√©ricos)
        if(any(!is.finite(probabilities)) || sum(probabilities) < 1e-10) {
           probabilities <- rep(1 / length(possible_nodes), length(possible_nodes))
        }
        probabilities <- probabilities / sum(probabilities) # Normalizar

        # Elegir el siguiente nodo basado en las probabilidades
        chosen_index <- if (length(possible_nodes) == 1) {
          1 # Si solo queda uno, elegir ese
        } else {
          sample(1:length(possible_nodes), 1, prob = probabilities)
        }
        next_node <- possible_nodes[chosen_index]

        # Actualizar ruta y estado de visitados
        current_tour[step] <- next_node
        visited[next_node] <- TRUE
        current_node <- next_node
      } # Fin construcci√≥n de ruta de la hormiga (step)

      # --- Calcular costo de la ruta construida ---
      current_length <- 0
      valid_tour <- TRUE
      # Verificar si se visitaron todos los nodos (importante si hubo 'break')
      if (!all(1:n_nodes %in% current_tour)) {
        valid_tour <- FALSE
        current_length <- Inf
      } else {
        # Calcular costo sumando segmentos
        for (i in 1:(n_nodes - 1)) {
          from_node <- current_tour[i]
          to_node <- current_tour[i+1]
          cost_segment <- cost_matrix[from_node, to_node]
          if (!is.finite(cost_segment)) { # Ruta inv√°lida si un segmento tiene costo Inf
            current_length <- Inf
            break
          }
          current_length <- current_length + cost_segment
        }
        # A√±adir costo de regreso al nodo inicial si la ruta es finita hasta ahora
        if (is.finite(current_length)) {
          from_node <- current_tour[n_nodes]
          to_node <- current_tour[1]
          cost_segment <- cost_matrix[from_node, to_node]
          if (!is.finite(cost_segment)) {
            current_length <- Inf # Ruta inv√°lida si el regreso es Inf
          } else {
            current_length <- current_length + cost_segment
          }
        }
      } # Fin c√°lculo de costo

      # Guardar ruta y costo de la hormiga
      all_tours[[ant]] <- if(valid_tour && is.finite(current_length)) current_tour else NULL
      all_lengths[ant] <- current_length

      # Actualizar la mejor soluci√≥n global si esta hormiga encontr√≥ una mejor
      if (is.finite(current_length) && current_length < best_length) {
        if(verbose) cat(sprintf("Iter %d, Hormiga %d: Nueva mejor longitud = %.2f\n", iter, ant, current_length))
        best_length <- current_length
        best_tour <- current_tour
        iter_found_new_best <- TRUE
      }
    } # Fin bucle de hormigas (ant)

    # --- Actualizaci√≥n de Feromonas ---
    # 1. Evaporaci√≥n
    pheromone_matrix <- (1 - rho) * pheromone_matrix

    # 2. Deposici√≥n
    delta_pheromone <- matrix(0, nrow = n_nodes, ncol = n_nodes) # Cambios en feromona para esta iteraci√≥n
    for (ant in 1:num_ants) {
      ant_tour <- all_tours[[ant]]
      ant_length <- all_lengths[ant]
      # Depositar solo si la ruta es v√°lida, completa y finita
      if (!is.null(ant_tour) && length(ant_tour) == n_nodes && all(ant_tour > 0) && is.finite(ant_length) && ant_length > 0) {
        deposit_amount <- Q / ant_length # Cantidad de feromona a depositar
        for (i in 1:(n_nodes - 1)) {
          node1 <- ant_tour[i]
          node2 <- ant_tour[i+1]
          # Depositar en ambas direcciones (sim√©trico para TSP)
          delta_pheromone[node1, node2] <- delta_pheromone[node1, node2] + deposit_amount
          delta_pheromone[node2, node1] <- delta_pheromone[node2, node1] + deposit_amount
        }
        # Depositar en el segmento de cierre (√∫ltimo a primero)
        node1 <- ant_tour[n_nodes]
        node2 <- ant_tour[1]
        delta_pheromone[node1, node2] <- delta_pheromone[node1, node2] + deposit_amount
        delta_pheromone[node2, node1] <- delta_pheromone[node2, node1] + deposit_amount
      }
    }
    pheromone_matrix <- pheromone_matrix + delta_pheromone

    # Asegurar un m√≠nimo de feromona y cero en diagonal
    pheromone_matrix[pheromone_matrix < 1e-10] <- 1e-10
    diag(pheromone_matrix) <- 0

    # --- Guardar historial de la iteraci√≥n ---
    # Guarda el mejor costo encontrado *hasta ahora* en esta iteraci√≥n
    history_best_length[iter] <- best_length
    # Guarda la mejor ruta encontrada *hasta ahora* en esta iteraci√≥n
    history_best_tours[[iter]] <- best_tour

    # Mensaje de progreso peri√≥dico
    if(verbose && iter %% 10 == 0) {
      cat(sprintf("--- Fin Iteraci√≥n %d: Mejor costo hasta ahora = %.2f ---\n", iter, best_length))
    }

  } # Fin bucle principal de iteraciones (iter)

  # Mensaje final
  if (verbose && is.infinite(best_length)) {
    cat("ACO: No se encontr√≥ ninguna ruta v√°lida finita.\n")
  } else if (verbose) {
    cat(sprintf("ACO: Optimizaci√≥n finalizada. Mejor longitud encontrada = %.2f\n", best_length))
  }

  # --- Preparar y devolver resultados ---
  # Intentar obtener nombres de ciudades si 'ciudades_nombres' existe y best_tour no es NULL
  best_tour_cities_result <- NULL
  if (!is.null(best_tour) && exists("ciudades_nombres")) {
     best_tour_cities_result <- try(ciudades_nombres[best_tour], silent = TRUE)
     if (inherits(best_tour_cities_result, "try-error")) {
         best_tour_cities_result <- "Error al obtener nombres" # O asignar NULL
     }
  } else if (is.null(best_tour)){
      best_tour_cities_result <- "No disponible (sin ruta)"
  } else {
      best_tour_cities_result <- "No disponible (ciudades_nombres no existe)"
  }


  return(list(
    best_tour_indices = best_tour,          # Vector de √≠ndices de la mejor ruta
    best_tour_cost = best_length,           # Costo num√©rico de la mejor ruta
    best_tour_cities = best_tour_cities_result, # Vector de nombres de ciudades (o mensaje)
    convergence_cost = history_best_length, # Vector num√©rico de costos por iteraci√≥n
    history_best_tours = history_best_tours # Lista de vectores de √≠ndices (rutas) por iteraci√≥n
  ))
}
```

Ahora, ejecutamos la funci√≥n `ant_colony_optimization_r_con_historial` con un conjunto de par√°metros definidos. Se establece una semilla (`set.seed`) para garantizar la reproducibilidad de los resultados, dado el componente probabil√≠stico del algoritmo.

Adicional, en la **figura 1** se observa como el algoritmo va obtendiendo mejores resultados al optimizar la funci√≥n.

```{r}
# Par√°metros de ejecuci√≥n
num_ants_aco <- 30
num_iterations_aco <- 100

set.seed(456) # Semilla para reproducibilidad
resultado_aco <- ant_colony_optimization_r_con_historial(
  costos = df_costo_total, # Asume que df_costo_total existe
  num_ants = num_ants_aco,
  num_iterations = num_iterations_aco,
  alpha = 1.0,
  beta = 3.0,
  rho = 0.3,
  Q = 100,
  verbose = TRUE
)

print("--- Resultado Final - Ejecuci√≥n ACO ---")
if (!is.null(resultado_aco) && is.finite(resultado_aco$best_tour_cost)) {
    print(paste("Mejor costo encontrado:", format(resultado_aco$best_tour_cost, scientific = FALSE, big.mark=",")))
    # Verificar si best_tour_cities existe y no es NULL antes de imprimir
    # Asume que 'ciudades_nombres' fue usado correctamente dentro de la funci√≥n ACO o existe globalmente
    if (!is.null(resultado_aco$best_tour_cities) && !inherits(resultado_aco$best_tour_cities, "try-error") && !startsWith(resultado_aco$best_tour_cities[1], "Error") && !startsWith(resultado_aco$best_tour_cities[1], "No disponible")) {
       print(paste("Mejor ruta (ciudades):", paste(resultado_aco$best_tour_cities, collapse = " -> ")))
    } else if (!is.null(resultado_aco$best_tour_indices)) {
        print(paste("Mejor ruta (√≠ndices):", paste(resultado_aco$best_tour_indices, collapse=" -> ")))
        print("Mejor ruta (ciudades): No disponible o error al obtener nombres.")
    } else {
       print("Mejor ruta (ciudades e √≠ndices): No disponible (best_tour fue NULL o inv√°lido).")
    }


    # --- Modificaci√≥n Aqu√≠: Graficar convergencia del costo CON CAPTION ---
    tryCatch({
        # --- Inicio: Ajustar y guardar m√°rgenes ---
        old_mar <- par("mar") # Guardar m√°rgenes originales [bottom, left, top, right]
        # Incrementar margen inferior (el primer valor) para dar espacio al caption
        new_mar <- old_mar + c(2, 0, 0, 0) # A√±adir 2 l√≠neas al margen inferior
        par(mar = new_mar)
        # --- Fin: Ajustar y guardar m√°rgenes ---

        # 1. Generar el gr√°fico con t√≠tulos y etiquetas
        plot(1:num_iterations_aco, resultado_aco$convergence_cost, type='l',
             col="steelblue", lwd=2, # Un poco de estilo
             xlab="Iteraci√≥n",
             ylab="Mejor Costo Encontrado",
             main="Convergencia del Costo en ACO")
        grid() # A√±adir una rejilla

        # 2. A√±adir el caption en el margen inferior
        caption_text <- "Figura 1: Evoluci√≥n del mejor costo acumulado encontrado por ACO en cada iteraci√≥n."
        # Ajusta 'line' (e.g., 4, 4.5, 5) si el caption se superpone con xlab
        mtext(caption_text, side = 1, line = 5, adj = 0, cex = 0.8)

        # --- Inicio: Restaurar m√°rgenes ---
        par(mar = old_mar) # Restaurar m√°rgenes originales para no afectar otros gr√°ficos
        # --- Fin: Restaurar m√°rgenes ---

      },
      error=function(e) {
        print(paste("Error al graficar convergencia ACO:", e$message))
        # Asegurarse de restaurar m√°rgenes incluso si hay error y old_mar existe
        if(exists("old_mar") && !is.null(old_mar)) {
           try(par(mar = old_mar), silent = TRUE) # Intenta restaurar
        }
      }
    )
    # --- Fin Modificaci√≥n ---

} else {
    print("ACO no encontr√≥ una soluci√≥n v√°lida o la ejecuci√≥n fall√≥.")
    # Podr√≠as imprimir resultado_aco aqu√≠ para depurar si es necesario
    # print(resultado_aco)
}
```

Para entender mejor c√≥mo el algoritmo refina la soluci√≥n, generamos una animaci√≥n que muestra la mejor ruta encontrada hasta cada iteraci√≥n. Primero, preparamos los datos del historial de rutas, convirtiendo los √≠ndices de las rutas en coordenadas geogr√°ficas y estructur√°ndolos para `gganimate` .

```{r}
# --- Preparar Datos del Historial para gganimate ---
# Asume que 'resultado_aco' (con historial), 'coords', y 'n_ciudades' ya existen

historial_rutas <- resultado_aco$history_best_tours
historial_costos <- resultado_aco$convergence_cost
all_segments_history <- data.frame() # DataFrame para segmentos hist√≥ricos

# Validar que el historial existe y tiene elementos
if (!is.null(historial_rutas) && length(historial_rutas) > 0) {
    
    # Usar el n√∫mero real de iteraciones guardadas
    num_iter_guardadas <- length(historial_rutas) 
    
    for (iter in 1:num_iter_guardadas) { 
      current_tour_indices <- historial_rutas[[iter]]
      # Asegurarse de que el √≠ndice de costo no exceda la longitud real
      current_cost <- if(iter <= length(historial_costos)) historial_costos[iter] else NA 
      
      # Procesar solo si hay una ruta v√°lida y costo v√°lido
      if (!is.null(current_tour_indices) && length(current_tour_indices) == n_ciudades && all(current_tour_indices > 0) && is.finite(current_cost)) {
        
        ruta_iter_coords <- coords[current_tour_indices, ]
        ruta_iter_coords <- rbind(ruta_iter_coords, ruta_iter_coords[1, ]) # Cerrar ciclo
        
        segmentos_iter <- data.frame(
          lon_inicio = head(ruta_iter_coords$lon, -1),
          lat_inicio = head(ruta_iter_coords$lat, -1),
          lon_fin = tail(ruta_iter_coords$lon, -1),
          lat_fin = tail(ruta_iter_coords$lat, -1),
          iteracion = iter, 
          costo = current_cost 
        )
        all_segments_history <- rbind(all_segments_history, segmentos_iter)
      } 
    }
}

# Verificar si se generaron segmentos
if(nrow(all_segments_history) == 0) {
    print("ADVERTENCIA: No se pudieron generar datos de segmentos del historial de ACO para la animaci√≥n.")
} else {
    print(paste("Se procesaron datos de", length(unique(all_segments_history$iteracion)), "iteraciones de ACO para la animaci√≥n."))
}


# --- Animaci√≥n del Proceso de Mejora de ACO ---
# Asume que 'all_segments_history', 'colombia', y 'coords' existen y son v√°lidos.
# Tambi√©n asume que las librer√≠as ggplot2, gganimate, sf, gifski est√°n cargadas.

# Solo intentar animar si hay datos v√°lidos
if(exists("all_segments_history") && nrow(all_segments_history) > 0) {

    # Crear mapa base
    mapa_base_historia <- ggplot() +
      geom_sf(data = colombia, fill = "ivory", color = "gray50") +
      geom_point(data = coords, aes(x = lon, y = lat), color = "darkblue", size = 3.0, alpha = 0.6) +
      theme_minimal(base_size = 11) +
      theme(plot.title = element_text(hjust = 0.5, face="bold"),
            plot.subtitle = element_text(hjust = 0.5)) +
      coord_sf(xlim = range(coords$lon) + c(-1.2, 1.2), ylim = range(coords$lat) + c(-1.2, 1.2), expand = FALSE)
    
    # Crear objeto de animaci√≥n
    animacion_proceso <- mapa_base_historia +
      geom_segment(data = all_segments_history,
                   aes(x = lon_inicio, y = lat_inicio, xend = lon_fin, yend = lat_fin),
                   color = "darkorange", size = 1.0, alpha = 0.8) + 
      transition_manual(iteracion) +  

      labs(
        title = "Proceso de Optimizaci√≥n ACO - Iteraci√≥n {frame}", 
        subtitle = "Mostrando la mejor ruta encontrada hasta esta iteraci√≥n", 
        caption = "Figura 2: Proceso de optimizaci√≥n ACO - Iteraciones. (Fuente: Elaboraci√≥n propia, 2025).", y = "Latitud"
      ) +
      ease_aes('linear') 
    
    # Renderizar animaci√≥n
    fps_proceso <- 5 # Velocidad de la animaci√≥n
    # Usar el n√∫mero de frames √∫nicos disponibles en los datos procesados
    total_frames_proceso <- length(unique(all_segments_history$iteracion)) 
    
    print(paste("Generando animaci√≥n del proceso ACO con", total_frames_proceso, "frames a", fps_proceso, "fps."))
    
    # Usar tryCatch para manejar posibles errores durante la renderizaci√≥n
    anim_render_proceso <- tryCatch({
        animate(
          animacion_proceso, 
          nframes = total_frames_proceso, 
          fps = fps_proceso, 
          width = 800, 
          height = 700, 
          renderer = gifski_renderer()
        )
    }, error = function(e) {
        print(paste("Error durante la renderizaci√≥n de la animaci√≥n:", e$message))
        return(NULL) # Devuelve NULL si falla
    })
    
    # Solo proceder si la renderizaci√≥n fue exitosa
    if (!is.null(anim_render_proceso)) {
      # Visualizar en Rmd/Viewer (se imprime autom√°ticamente por defecto en Rmd si es la √∫ltima expresi√≥n)
      # print(anim_render_proceso) # Descomentar si no se muestra autom√°ticamente
      
      # Guardar
      tryCatch({
          anim_save("proceso_optimizacion_aco_optimizado.gif", animation = anim_render_proceso)
          print("Animaci√≥n del proceso ACO guardada como proceso_optimizacion_aco_optimizado.gif")
      }, error = function(e) {
          print(paste("Error al guardar la animaci√≥n:", e$message))
      })
      
    } # Fin if !is.null(anim_render_proceso)

} else {
  print("No hay datos hist√≥ricos v√°lidos para generar la animaci√≥n del proceso ACO.")
}
```

La animaci√≥n resultante (**Figura 2**) ilustra c√≥mo la mejor ruta encontrada por el algoritmo ACO evoluciona a lo largo de las iteraciones, tendiendo a estabilizarse a medida que el algoritmo converge hacia una soluci√≥n de bajo costo.

```{r}
knitr::include_graphics("proceso_optimizacion_aco_optimizado.gif")
```

Continuando con con el **Algoritmo Genetico**:

Continuando con las metaheur√≠sticas, ahora abordamos los **Algoritmos Gen√©ticos (AG)**, una clase de algoritmos de optimizaci√≥n inspirados en el proceso de la evoluci√≥n natural y la gen√©tica. Los AG son particularmente efectivos para problemas complejos donde el espacio de b√∫squeda es grande, como el Problema del Viajante de Comercio.

El enfoque se basa en mantener y evolucionar una **poblaci√≥n** de soluciones candidatas al problema. En nuestro contexto del TSP, cada 'individuo' de la poblaci√≥n es una **ruta** o secuencia espec√≠fica de visita a las ciudades. Cada ruta se representa mediante una codificaci√≥n, an√°loga a un **cromosoma** (usualmente, una permutaci√≥n de los √≠ndices o nombres de las ciudades).

El algoritmo opera en ciclos llamados **generaciones**. En cada generaci√≥n, se simula el proceso evolutivo mediante los siguientes pasos clave [inspirados en conceptos descritos por Wikipedia (s.f.) y otros]:

1.  **Evaluaci√≥n:** Se calcula la **aptitud (fitness)** de cada ruta en la poblaci√≥n. Para el TSP, una mayor aptitud corresponde a un menor costo total del recorrido (usualmente se define como el inverso del costo o alguna funci√≥n decreciente del costo).

2.  **Selecci√≥n:** Se seleccionan las rutas 'padres' que contribuir√°n a la siguiente generaci√≥n. Las rutas con mayor aptitud tienen una mayor probabilidad de ser elegidas, simulando la "supervivencia del m√°s apto".

3.  **Cruzamiento (Crossover):** Se combinan pares de rutas padres para crear nuevas rutas 'hijas'. Este proceso mezcla segmentos o caracter√≠sticas de las rutas progenitoras, buscando generar nuevas combinaciones potencialmente mejores.

4.  **Mutaci√≥n:** Se aplican peque√±as alteraciones aleatorias a algunas de las nuevas rutas (o a veces a individuos existentes). En el TSP, esto podr√≠a implicar intercambiar la posici√≥n de dos ciudades en la secuencia. La mutaci√≥n introduce diversidad gen√©tica en la poblaci√≥n y ayuda a evitar que el algoritmo se estanque prematuramente en soluciones sub√≥ptimas.

5.  **Reemplazo:** Se forma la poblaci√≥n para la siguiente generaci√≥n, decidiendo qu√© individuos (padres, hijos) sobreviven. Existen diversas estrategias, como reemplazar a los menos aptos o mantener a los mejores ('elitismo').

A trav√©s de la aplicaci√≥n repetida de estos operadores gen√©ticos (selecci√≥n, cruzamiento, mutaci√≥n) durante muchas generaciones, la poblaci√≥n tiende a converger hacia rutas de muy alta calidad (bajo costo).

A continuaci√≥n, se presenta la funci√≥n en R que implementa el Algoritmo Gen√©tico dise√±ado para resolver nuestro problema del viajante.

```{r}
calculate_tour_cost <- function(tour, cost_matrix) {
  total_cost <- 0
  n <- length(tour)
  
  if (n < 2) return(Inf) 
  
  for (i in 1:(n - 1)) { 
    idx1 <- tour[i]
    idx2 <- tour[i+1]
    
    # Validaci√≥n de √≠ndices
    if(any(is.na(c(idx1,idx2))) || idx1 < 1 || idx1 > nrow(cost_matrix) || idx2 < 1 || idx2 > ncol(cost_matrix)) {
      return(Inf)
    }
      
    cost <- cost_matrix[idx1, idx2]
    if (!is.finite(cost)) {
      return(Inf)
    }
      
    total_cost <- total_cost + cost 
  }
  
  
  idx1 <- tour[n]
  idx2 <- tour[1]
  
  if(any(is.na(c(idx1,idx2))) || idx1 < 1 || idx1 > nrow(cost_matrix) || idx2 < 1 || idx2 > ncol(cost_matrix)) {
    return(Inf)
  }
    
  cost_return <- cost_matrix[idx1, idx2]
  if (!is.finite(cost_return)) {
    return(Inf)
  }
    
  total_cost <- total_cost + cost_return
  return(total_cost)
}

fitness_function <- function(tour, cost_matrix) { 
  cost <- calculate_tour_cost(tour, cost_matrix)
  if (is.infinite(cost)) { 
    # Devolver valor muy negativo pero finito si el costo es Infinito
    return(-1e+100) 
  } else { 
    # Devolver negativo del costo
    return(-cost) 
  } 
}

# Listas externas para guardar historial (se deben limpiar antes de llamar a ga)
ga_history_best_tours <- list()
ga_history_best_costs <- list()

# Funci√≥n Monitor personalizada para GA
monitor_ga_history <- function(object, ...) { 
  iter <- object@iter
  best_fitness_current_gen <- max(object@fitness, na.rm = TRUE)
  
  # No hacer nada si no hay fitness finito
  if (!is.finite(best_fitness_current_gen)) {
    return() 
  }
    
  best_indices_current_gen <- which(object@fitness == best_fitness_current_gen)
  
  if (length(best_indices_current_gen) > 0) { 
    # Tomar la primera mejor soluci√≥n en caso de empate
    best_solution_current_gen <- object@population[best_indices_current_gen[1], ]
    actual_cost <- -best_fitness_current_gen
    
    # Guardar en listas externas usando superasignaci√≥n (<<-)
    ga_history_best_tours[[as.character(iter)]] <<- as.vector(best_solution_current_gen)
    ga_history_best_costs[[as.character(iter)]] <<- actual_cost
    
    # Imprimir progreso cada 20 generaciones o en la primera
    if (iter %% 20 == 0 || iter == 1) {
      cat(sprintf("GA Gen %d: Mejor Costo (Gen actual) = %.2f\n", iter, actual_cost)) 
    }
  } # Fin if best_indices
} # Fin monitor_ga_history



# Resetear listas de historial antes de la ejecuci√≥n
ga_history_best_tours <- list()
ga_history_best_costs <- list() 

# Fijar semilla y n√∫mero de generaciones
set.seed(456)
num_generations_ga <- 200 

# Ejecutar GA usando tryCatch para manejo de errores
resultado_ga <- tryCatch({
  ga(
    type = "permutation", 
    fitness = fitness_function, 
    cost_matrix = df_costo_total, 
    lower = 1, 
    upper = n_ciudades, 
    popSize = 100, 
    maxiter = num_generations_ga, 
    run = 100, 
    pmutation = 0.2, 
    pcrossover = 0.8, 
    elitism = max(1, floor(0.1 * 100)), 
    monitor = monitor_ga_history, # Usar el monitor personalizado
    seed = 123
  )
}, error = function(e) {
    # Imprimir error y devolver NULL si falla
    print(paste("Error durante la ejecuci√≥n de GA:", e$message))
    return(NULL)
})

# Verificar resultado de la ejecuci√≥n
if (!is.null(resultado_ga)) { 
  print("Ejecuci√≥n GA finalizada.")
  print(paste("Historial GA guardado para", length(ga_history_best_tours), "generaciones.")) 
} else { 
  print("Ejecuci√≥n GA fall√≥.")
}

print("--- Resultados Finales GA ---")

# Solo mostrar si la ejecuci√≥n fue exitosa
if (!is.null(resultado_ga)) {
  
  # Inicializar variables de resultado
  best_tour_indices_ga <- NULL
  best_tour_cost_ga <- Inf
  best_tour_cities_ga <- "No disponible"
  
  # Extraer la mejor soluci√≥n final si es v√°lida
  if (length(resultado_ga@solution) > 0 && is.finite(resultado_ga@fitnessValue)) { 
    best_tour_indices_ga <- resultado_ga@solution[1,] # Primera mejor soluci√≥n
    best_tour_cost_ga <- -resultado_ga@fitnessValue  # Costo real (positivo)
    
    # Obtener nombres de ciudades (si existen)
    best_tour_cities_ga <- tryCatch(
        ciudades_nombres[best_tour_indices_ga], 
        error = function(e) "Error al obtener nombres"
    ) 
  } else { 
    print("Advertencia: No se encontr√≥ soluci√≥n final GA v√°lida.")
  }
  
  # Imprimir resultados finales formateados
  print(paste("Mejor costo GA:", format(best_tour_cost_ga, scientific = FALSE, big.mark=",")))
  if (!is.null(best_tour_indices_ga)) {
     print(paste("Mejor ruta GA (√≠ndices):", paste(best_tour_indices_ga, collapse = " -> "))) 
  } else {
      print("Mejor ruta GA (√≠ndices): No disponible")
  }
  print(paste("Mejor ruta GA (ciudades):", paste(best_tour_cities_ga, collapse = " -> ")))
  
  # Graficar convergencia est√°ndar del paquete GA
 tryCatch({
      # --- Inicio: Ajustar y guardar m√°rgenes ---
      old_mar <- par("mar") # Guardar m√°rgenes originales [bottom, left, top, right]
      # Incrementar margen inferior (el primer valor) para dar espacio al caption
      # Aumentamos de 5.1 (default usual) a 6.1 o 7.1, probemos con +2 l√≠neas
      new_mar <- old_mar + c(2, 0, 0, 0)
      par(mar = new_mar)
      # --- Fin: Ajustar y guardar m√°rgenes ---

      # 1. Generar el gr√°fico base
      plot(resultado_ga)

      # 2. A√±adir las etiquetas y el t√≠tulo
      title(main = "Convergencia del Algoritmo Gen√©tico (GA)")


      caption_text <- "Figura 3: Evoluci√≥n del mejor fitness (verde) y fitness promedio (azul) por generaci√≥n."

      mtext(caption_text, side = 1, line = 5, adj = 0, cex = 0.8)

      # --- Inicio: Restaurar m√°rgenes ---
      par(mar = old_mar) # Restaurar m√°rgenes originales para no afectar otros gr√°ficos
      # --- Fin: Restaurar m√°rgenes ---

    },
    error=function(e) {
      print(paste("Error al graficar o rotular GA:", e$message))
      # Asegurarse de restaurar m√°rgenes incluso si hay error y old_mar existe
      if(exists("old_mar") && !is.null(old_mar)) {
         try(par(mar = old_mar), silent = TRUE) # Intenta restaurar
      }
    }
  )
  
} else { 
  print("No hay resultados finales GA para mostrar.") 
}



# Data frame para almacenar todos los segmentos de todas las generaciones
all_segments_history_ga <- data.frame()

# Procesar solo si hay historial y coordenadas
if (length(ga_history_best_tours) > 0 && exists("coords")) {
  
  generaciones_guardadas <- names(ga_history_best_tours)
  
  # Iterar sobre cada generaci√≥n guardada
  for (gen_char in generaciones_guardadas) {
    gen <- as.numeric(gen_char)
    current_tour_indices <- ga_history_best_tours[[gen_char]]
    current_cost <- ga_history_best_costs[[gen_char]]
    
    # Validar ruta y costo antes de procesar
    if (!is.null(current_tour_indices) && 
        length(current_tour_indices) == n_ciudades && 
        all(current_tour_indices > 0) && 
        is.finite(current_cost)) {
      
      # Obtener coordenadas y verificar validez
      ruta_gen_coords <- coords[current_tour_indices, ]
      if(nrow(ruta_gen_coords) == n_ciudades && !any(is.na(ruta_gen_coords$lon))) { 
        
        # A√±adir primera ciudad al final para cerrar el ciclo
        ruta_gen_coords <- rbind(ruta_gen_coords, ruta_gen_coords[1, ])
        
        # Crear dataframe de segmentos para esta generaci√≥n
        segmentos_gen <- data.frame(
          lon_inicio = head(ruta_gen_coords$lon, -1), 
          lat_inicio = head(ruta_gen_coords$lat, -1), 
          lon_fin = tail(ruta_gen_coords$lon, -1), 
          lat_fin = tail(ruta_gen_coords$lat, -1), 
          generacion = gen, 
          costo = current_cost
        )
        
        # A√±adir al dataframe general
        all_segments_history_ga <- rbind(all_segments_history_ga, segmentos_gen) 
      } # Fin if coordenadas v√°lidas
    } # Fin if ruta/costo v√°lido
  } # Fin for loop
} # Fin if historial existe

# Verificar si se generaron datos para la animaci√≥n
if(nrow(all_segments_history_ga) == 0) { 
  print("ADVERTENCIA: No se generaron datos de historial GA para animaci√≥n.") 
} else { 
  print(paste("Datos de historial GA procesados para", length(unique(all_segments_history_ga$generacion)), "generaciones.")) 
}
```

En la **figura 3** se nota como obtiene mejores resultados en especial en el "Best" a medida que el algoritmo avanza en las generaciones.

Creamos la animaci√≥n para los algortimos geneticos:

```{r}
# Solo animar si hay datos y mapa base
if(exists("all_segments_history_ga") && nrow(all_segments_history_ga) > 0 && exists("colombia")) {
  
    # 1. Gr√°fico Base
    mapa_base_historia_ga <- ggplot() + 
      geom_sf(data = colombia, fill = "lightblue", color = "gray50") +
      geom_point(data = coords, aes(x = lon, y = lat), color = "navy", size = 3.0, alpha = 0.6) +
      theme_minimal(base_size = 11) + 
      theme(plot.title = element_text(hjust = 0.5, face="bold"), 
            plot.subtitle = element_text(hjust = 0.5)) +
      coord_sf(xlim = range(coords$lon, na.rm=T) + c(-1.2, 1.2), 
               ylim = range(coords$lat, na.rm=T) + c(-1.2, 1.2), 
               expand = FALSE)

    # 2. Objeto de Animaci√≥n
    animacion_proceso_ga <- mapa_base_historia_ga +
      geom_segment(
        data = all_segments_history_ga, 
        aes(x = lon_inicio, y = lat_inicio, xend = lon_fin, yend = lat_fin), 
        color = "purple", size = 1.0, alpha = 0.8
      ) + 
      transition_manual(generacion) + 
      labs(
        title = "Proceso GA - Generaci√≥n {frame}", 
        subtitle = "Mejor ruta encontrada en esta generaci√≥n", 
        caption = "Figura 4: Proceso de optimizaci√≥n ACO(Fuente: Elaboraci√≥n propia, 2025)", 
        x = "Longitud", y = "Latitud"
      ) + 
      ease_aes('linear') 
      
    # 3. Par√°metros de Renderizado
    fps_proceso_ga <- 7
    total_frames_proceso_ga <- length(unique(all_segments_history_ga$generacion))
    
    print(paste("Renderizando animaci√≥n GA:", total_frames_proceso_ga, "frames a", fps_proceso_ga, "fps."))
    
    # 4. Renderizar (con tryCatch)
    anim_render_proceso_ga <- tryCatch({
      animate(
        animacion_proceso_ga, 
        nframes = total_frames_proceso_ga, 
        fps = fps_proceso_ga, 
        width = 800, 
        height = 700, 
        renderer = gifski_renderer()
      )
    }, error=function(e){
        print(paste("Error renderizando animaci√≥n GA:", e$message))
        return(NULL)
    })
    
    # 5. Visualizar y Guardar (si renderizaci√≥n fue exitosa)
    if (!is.null(anim_render_proceso_ga)) { 
      # Mostrar en dispositivo gr√°fico / Rmd
      print(anim_render_proceso_ga)
      
      # Guardar
      tryCatch({
          anim_save("proceso_optimizacion_ga.gif", animation = anim_render_proceso_ga)
          print("Animaci√≥n Proceso GA guardada.") 
      }, error=function(e) {
          print(paste("Error guardando animaci√≥n GA:", e$message))
      })
    } else { 
      print("Fallo al renderizar animaci√≥n GA.") 
    }
    
} else { 
  print("No hay datos/mapa para generar animaci√≥n GA.") 
} 
```

La animaci√≥n resultante (**Figura 4**) ilustra c√≥mo la mejor ruta encontrada por el algoritmo AG evoluciona a lo largo de las iteraciones, tendiendo a estabilizarse a medida que el algoritmo converge hacia una soluci√≥n de bajo costo.

```{r}
knitr::include_graphics("proceso_optimizacion_ga.gif")
```

Comparando ambos algoritmos:

```{r}
costo_aco <-
  if (!is.null(resultado_aco) && is.finite(resultado_aco$best_tour_cost)) {
    resultado_aco$best_tour_cost
  } else {
    Inf # Asignar Infinito si no hay resultado v√°lido
  }
indices_aco <-
  if (!is.null(resultado_aco) && is.finite(resultado_aco$best_tour_cost)) {
    resultado_aco$best_tour_indices
  } else {
    NULL # Asignar NULL si no hay resultado v√°lido
  }

costo_ga <- if (exists("best_tour_cost_ga") && is.finite(best_tour_cost_ga)) best_tour_cost_ga else Inf
indices_ga <- if (exists("best_tour_indices_ga") && is.finite(best_tour_cost_ga)) best_tour_indices_ga else NULL

if (is.infinite(costo_aco) && is.infinite(costo_ga)) {
  print("Error: Ninguno de los algoritmos encontr√≥ una soluci√≥n v√°lida.")
  final_best_cost <- Inf
  final_best_tour_indices <- NULL
  algoritmo_ganador <- "Ninguno"
} else {
  if (costo_ga < costo_aco) {
    algoritmo_ganador <- "Algoritmo Gen√©tico (GA)"
    final_best_cost <- costo_ga
    final_best_tour_indices <- indices_ga
    print(paste("GA encontr√≥ una mejor soluci√≥n (Costo:", format(final_best_cost, scientific = FALSE, big.mark=","), ")"))
    print(paste("  (Costo ACO:", format(costo_aco, scientific = FALSE, big.mark=","), ")"))
  } else if (costo_aco < costo_ga) {
    algoritmo_ganador <- "Colonia de Hormigas (ACO)"
    final_best_cost <- costo_aco
    final_best_tour_indices <- indices_aco
    print(paste("ACO encontr√≥ una mejor soluci√≥n (Costo:", format(final_best_cost, scientific = FALSE, big.mark=","), ")"))
    print(paste("  (Costo GA:", format(costo_ga, scientific = FALSE, big.mark=","), ")"))
  } else { # Costos iguales
    algoritmo_ganador <- "Ambos (costo igual)"
    final_best_cost <- costo_ga # O costo_aco, son iguales
    # Podemos elegir arbitrariamente GA en caso de empate, o mantener ambas si quisi√©ramos
    final_best_tour_indices <- indices_ga 
    print(paste("Ambos algoritmos encontraron soluciones con el mismo costo:", format(final_best_cost, scientific = FALSE, big.mark=",")))
  }
  
  # Imprimir la mejor ruta encontrada
  if (!is.null(final_best_tour_indices)) {
      final_best_tour_cities <- ciudades_nombres[final_best_tour_indices]
      print(paste("Mejor ruta encontrada por", algoritmo_ganador, ":"))
      print(paste(final_best_tour_cities, collapse = " -> "))
  }
}
```

En conclusi√≥n, el GA super√≥ al ACO en ‚âà 16 % de ahorro de costo, lo que indica que, con la configuraci√≥n actual, el GA explor√≥ el espacio de soluciones de forma m√°s efectiva para este problema de rutas entre 13 ciudades.

La mejor ruta hallada por el GA cubre primero el suroccidente (Pasto ‚Üí Cali ‚Üí Pereira ‚Üí Manizales ‚Üí Medell√≠n) y luego ‚Äúsalta‚Äù a la costa Caribe (Cartagena ‚Üí Barranquilla ‚Üí Santa Marta), para finalmente recorrer el nororiente y centro (C√∫cuta ‚Üí Bucaramanga ‚Üí Bogot√° ‚Üí Ibagu√© ‚Üí Neiva).\
Ese orden evita retornos largos y, al juntar tramos geogr√°ficamente cercanos, reduce tanto distancias como tiempo de conducci√≥n.

En contraste, el **ACO** depende fuertemente de los par√°metros de feromonas (Œ±, Œ≤, tasa de evaporaci√≥n ). Si la evaporaci√≥n es alta o la influencia heur√≠stica (Œ≤) es baja, las hormigas pueden dispersarse demasiado y tardar m√°s en reforzar la mejor ruta. Con los valores actuales, el ACO sigui√≥ mejorando pero no alcanz√≥ la calidad que el GA obtuvo antes de que se cumpliera su criterio de parada.

# Bibliograf√≠a {#bibliograf√≠a}

La informaci√≥n sobre las distancias viales entre ciudades y tiempos de conducci√≥n fue obtenida de: Google LLC. (2025). *Distance Matrix API*. Google Maps Platform. <https://developers.google.com/maps/documentation/distance-matrix>

Informaci√≥n sobre el salario m√≠nimo: Ministerio de Trabajo. (2025). *Presidente decreto salario m√≠nimo para 2025 qued√≥ en 1.623.500, incluido auxilio de transporte*. Recuperado el 25 de abril de 2025, de <https://www.mintrabajo.gov.co/presidente-decreto-salario-minimo-para-2025-quedo-en-1.623.500-incluido-auxilio-de-transporte>

Informaci√≥n sobre el costo de combustible : Comisi√≥n de Regulaci√≥n de Energ√≠a y Gas (CREG). (2025). *Informe sobre precios de combustibles en Colombia*. Recuperado el 25 de abril de 2025, de <https://creg.gov.co/publicaciones/15565/precios-de-combustibles-liquidos/>

Informaci√≥n sobre el consumo de combustible: El Carro Colombiano. (2025). *Kia Picanto 2025: caracter√≠sticas y precios*. Recuperado el 25 de abril de 2025, de <https://www.elcarrocolombiano.com/pruebas/kia-picanto-1-0l-vs-kia-picanto-1-25l-automatico-2018/>

Wikipedia. (s.f.). *Algoritmo de la colonia de hormigas*. *Wikipedia, La enciclopedia libre*. Recuperado el 28 de abril de 2025, de <https://es.wikipedia.org/wiki/Algoritmo_de_la_colonia_de_hormigas>

Wikipedia. (s.f.). *Algoritmo gen√©tico*. *Wikipedia, La enciclopedia libre*. Recuperado el 28 de abril de 2025, de <https://es.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico>

# Reporte de Contribuci√≥n Individual {#reporte-de-contribuci√≥n-individual}

**Carlos Jos√© Quijano Valencia**: Responsable de la Parte 2 (Optimizaci√≥n combinatoria), levantamiento de supuestos de costo (salario, peajes, combustible, veh√≠culo de referencia), construcci√≥n de la matriz de distancias y tiempos con la Google Distance Matrix API, implementaci√≥n en R de los algoritmos Gen√©tico (GA) y Colonia de Hormigas (ACO) para el TSP de las 13 ciudades, an√°lisis comparativo de costos GA vs ACO y redacci√≥n de conclusiones, generaci√≥n de la animaci√≥n GIF con el recorrido √≥ptimo sobre el mapa de Colombia, documentaci√≥n del c√≥digo y subida al repositorio Git.
