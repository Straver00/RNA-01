df_distancias
#df_tiempos_viajes
#df_peajes
#crear df_peajes a partir de df_distancias entre más alto sea la distnacia más será el peaje
df_peajes <- df_distancias * 500
df_peajes
df_distancias
#df_tiempos_viajes
#df_peajes
#crear df_peajes a partir de df_distancias entre más alto sea la distnacia más será el peaje
df_peajes <- df_distancias * 300
df_peajes
df_distancias
#df_tiempos_viajes
#df_peajes
#crear df_peajes a partir de df_distancias entre más alto sea la distnacia más será el peaje
df_peajes <- df_distancias * 350
df_peajes
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/60
df_tiempo_viajes
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/60
df_tiempos_viajes
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/50
df_tiempos_viajes
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/45
df_tiempos_viajes
View(df_distancias)
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/50
df_tiempos_viajes
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
View(df_costo_gasolina)
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/45
df_tiempos_viajes
df_costo_gasolina <- (df_distancias/consumo_combustible) * precio_gasolina
df_costo_salario <- df_tiempos_viajes_horas * salario_hora
df_tiempos_viajes <- df_distancias/43
df_tiempos_viajes
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv
write.csv(df_costo_total, file = "costo_total.csv", row.names = FALSE)
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv
write.csv(df_costo_total, file = "costo_total.csv")
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv", row.names = FALSE)
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv", row.names = FALSE)
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
write.csv(df_costo_total, "costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
df_costo_total <- df_costo_gasolina + df_costo_salario + df_peajes
df_costo_total
#exportar dtf_costo_total a csv, verificando que no exista el archivo
if (file.exists("costo_total.csv")) {
file.remove("costo_total.csv")
write.csv(df_costo_total, "costo_total.csv")
} else {
write.csv(df_costo_total, "costo_total.csv")
}
# Cargar las librerías necesarias
library(ggplot2)
library(gganimate)
library(tidyverse)
'
packages <- c("ggplot2", "dplyr", "sf", "sp", "maps", "animation", "GA", "tidyverse")
for(pkg in packages) {
if(!require(pkg, character.only = TRUE)) {
install.packages(pkg)
library(pkg, character.only = TRUE)
}
}
'
# Cargar las librerías necesarias
library(ggplot2)
library(gganimate)
library(tidyverse)
# Cargar las librerías necesarias
library(ggplot2)
library(gganimate)
library(tidyverse)
'
packages <- c("ggplot2", "dplyr", "sf", "sp", "maps", "animation", "GA", "tidyverse")
for(pkg in packages) {
if(!require(pkg, character.only = TRUE)) {
install.packages(pkg)
library(pkg, character.only = TRUE)
}
}
'
'
packages <- c("ggplot2", "dplyr", "sf", "sp", "maps", "animation", "GA", "tidyverse")
for(pkg in packages) {
if(!require(pkg, character.only = TRUE)) {
install.packages(pkg)
library(pkg, character.only = TRUE)
}
}
install.packages("tidyverse")
'
# Cargar las librerías necesarias
library(ggplot2)
library(gganimate)
library(tidyverse)
# Cargar las librerías necesarias
install.packages("tidyverse")
library(ggplot2)
library(gganimate)
library(tidyverse)
# Paso 1: Tener la matriz de costos
df_costo_total
# Paso 2: Definir parámetros del algoritmo ACO
num_hormigas <- 50
num_iteraciones <- 100
evaporacion <- 0.5
factor_feromona <- 1
factor_heuristica <- 1
# Paso 3: Inicialización
ciudades <- rownames(df_costo_total)
num_ciudades <- length(ciudades)
# Inicializar la matriz de feromonas (igual en todas las rutas al principio)
feromonas <- matrix(1, nrow = num_ciudades, ncol = num_ciudades)
# Paso 4: Función para calcular la probabilidad de elegir el siguiente nodo
calcular_probabilidad <- function(feromonas, costos, ciudad_actual, ciudades_no_visitadas) {
probabilidad <- numeric(length(ciudades_no_visitadas))
for (i in 1:length(ciudades_no_visitadas)) {
ciudad_siguiente <- ciudades_no_visitadas[i]
probabilidad[i] <- (feromonas[ciudad_actual, ciudad_siguiente]^factor_feromona) *
((1 / costos[ciudad_actual, ciudad_siguiente])^factor_heuristica)
}
probabilidad <- probabilidad / sum(probabilidad)  # Normalizar
return(probabilidad)
}
# Paso 5: Ejecutar el algoritmo de colonia de hormigas
mejor_recorrido <- NULL
mejor_costo <- Inf
for (iter in 1:num_iteraciones) {
recorridos <- list()
costos_recorridos <- numeric(num_hormigas)
for (hormiga in 1:num_hormigas) {
recorrido <- numeric(num_ciudades)
costo_recorrido <- 0
visitadas <- rep(FALSE, num_ciudades)
# Empezar desde una ciudad aleatoria
ciudad_actual <- sample(1:num_ciudades, 1)
recorrido[1] <- ciudad_actual
visitadas[ciudad_actual] <- TRUE
# Recorrer todas las ciudades
for (i in 2:num_ciudades) {
ciudades_no_visitadas <- which(!visitadas)
probabilidad <- calcular_probabilidad(feromonas, df_costo_total, ciudad_actual, ciudades_no_visitadas)
ciudad_siguiente <- sample(ciudades_no_visitadas, 1, prob = probabilidad)  # Elegir la ciudad siguiente
recorrido[i] <- ciudad_siguiente
visitadas[ciudad_siguiente] <- TRUE
costo_recorrido <- costo_recorrido + df_costo_total[ciudad_actual, ciudad_siguiente]
ciudad_actual <- ciudad_siguiente
}
recorridos[[hormiga]] <- recorrido
costos_recorridos[hormiga] <- costo_recorrido
# Actualizar el mejor recorrido
if (costo_recorrido < mejor_costo) {
mejor_costo <- costo_recorrido
mejor_recorrido <- recorrido
}
}
# Paso 6: Actualizar feromonas
feromonas <- (1 - evaporacion) * feromonas  # Evaporación de feromonas
for (hormiga in 1:num_hormigas) {
recorrido <- recorridos[[hormiga]]
for (i in 1:(num_ciudades - 1)) {
ciudad_actual <- recorrido[i]
ciudad_siguiente <- recorrido[i + 1]
feromonas[ciudad_actual, ciudad_siguiente] <- feromonas[ciudad_actual, ciudad_siguiente] + factor_feromona / costos_recorridos[hormiga]
feromonas[ciudad_siguiente, ciudad_actual] <- feromonas[ciudad_siguiente, ciudad_actual] + factor_feromona / costos_recorridos[hormiga]
}
}
}
ant_colony_optimization <- function(df_costo_total, num_ants, num_iterations) {
# Inicializar feromonas
pheromones <- matrix(1, nrow = nrow(df_costo_total), ncol = ncol(df_costo_total))
best_route <- NULL
best_cost <- Inf
for (iteration in 1:num_iterations) {
for (ant in 1:num_ants) {
# Inicializar ruta y costo
route <- sample(1:nrow(df_costo_total), nrow(df_costo_total))
cost <- sum(df_costo_total[route, route])
# Actualizar mejor ruta
if (cost < best_cost) {
best_cost <- cost
best_route <- route
}
# Actualizar feromonas
pheromones[route, route] <- pheromones[route, route] + (1 / cost)
}
# Evaporar feromonas
pheromones <- pheromones * 0.9
}
return(list(route = best_route, cost = best_cost))
}
# Algoritmo de Colonia de Hormigas para el Problema del Viajante usando datos de ciudades colombianas
# Cargar los datos
datos <- read.csv("costo_total.csv", row.names = 1)
# Convertir a matriz
distancias <- as.matrix(datos)
# Parámetros del algoritmo
num_ciudades <- nrow(distancias)
num_hormigas <- 20
max_iter <- 100
alpha <- 1       # Importancia de las feromonas
beta <- 2        # Importancia de la distancia (heurística)
rho <- 0.5       # Tasa de evaporación de feromonas
Q <- 100         # Constante para la actualización de feromonas
# Inicializar matriz de feromonas
feromonas <- matrix(1, num_ciudades, num_ciudades)
diag(feromonas) <- 0  # No hay feromonas en la diagonal (no se visita la misma ciudad)
# Función para calcular la probabilidad de selección de una ciudad
calcular_probabilidades <- function(ciudad_actual, visitadas, feromonas, distancias, alpha, beta) {
probabilidades <- rep(0, num_ciudades)
for (i in 1:num_ciudades) {
if (!(i %in% visitadas)) {
# Calcular la probabilidad según la fórmula del ACO
tau <- feromonas[ciudad_actual, i] ^ alpha
eta <- (1 / distancias[ciudad_actual, i]) ^ beta
probabilidades[i] <- tau * eta
}
}
# Normalizar para que la suma sea 1
if (sum(probabilidades) > 0) {
probabilidades <- probabilidades / sum(probabilidades)
}
return(probabilidades)
}
# Función para seleccionar la siguiente ciudad según las probabilidades
seleccionar_siguiente_ciudad <- function(probabilidades) {
ciudades <- 1:length(probabilidades)
siguiente <- sample(ciudades, 1, prob = probabilidades)
return(siguiente)
}
# Función para calcular la longitud de una ruta
calcular_longitud_ruta <- function(ruta, distancias) {
longitud <- 0
for (i in 1:(length(ruta) - 1)) {
longitud <- longitud + distancias[ruta[i], ruta[i+1]]
}
# Agregar el regreso a la ciudad inicial
longitud <- longitud + distancias[ruta[length(ruta)], ruta[1]]
return(longitud)
}
# Algoritmo principal de Colonia de Hormigas
mejor_ruta <- NULL
mejor_longitud <- Inf
historial_mejores <- numeric(max_iter)
set.seed(123)  # Para reproducibilidad
for (iter in 1:max_iter) {
# Matriz para almacenar la cantidad de feromonas a agregar
delta_feromonas <- matrix(0, num_ciudades, num_ciudades)
# Para cada hormiga
for (k in 1:num_hormigas) {
# Ciudad inicial aleatoria
ciudad_inicial <- sample(1:num_ciudades, 1)
ruta <- ciudad_inicial
visitadas <- ciudad_inicial
# Construir ruta completa
while (length(visitadas) < num_ciudades) {
ciudad_actual <- ruta[length(ruta)]
probabilidades <- calcular_probabilidades(ciudad_actual, visitadas, feromonas, distancias, alpha, beta)
siguiente_ciudad <- seleccionar_siguiente_ciudad(probabilidades)
ruta <- c(ruta, siguiente_ciudad)
visitadas <- c(visitadas, siguiente_ciudad)
}
# Calcular longitud de la ruta
longitud <- calcular_longitud_ruta(ruta, distancias)
# Actualizar la mejor ruta encontrada
if (longitud < mejor_longitud) {
mejor_ruta <- ruta
mejor_longitud <- longitud
}
# Actualizar la matriz de delta_feromonas
for (i in 1:(length(ruta) - 1)) {
delta_feromonas[ruta[i], ruta[i+1]] <- delta_feromonas[ruta[i], ruta[i+1]] + Q / longitud
delta_feromonas[ruta[i+1], ruta[i]] <- delta_feromonas[ruta[i+1], ruta[i]] + Q / longitud
}
# Agregar feromonas para el regreso a la ciudad inicial
delta_feromonas[ruta[length(ruta)], ruta[1]] <- delta_feromonas[ruta[length(ruta)], ruta[1]] + Q / longitud
delta_feromonas[ruta[1], ruta[length(ruta)]] <- delta_feromonas[ruta[1], ruta[length(ruta)]] + Q / longitud
}
# Evaporación de feromonas
feromonas <- (1 - rho) * feromonas
# Agregar nuevas feromonas
feromonas <- feromonas + delta_feromonas
# Almacenar la mejor longitud de esta iteración
historial_mejores[iter] <- mejor_longitud
# Mostrar progreso cada 10 iteraciones
if (iter %% 10 == 0) {
cat("Iteración", iter, "- Mejor longitud:", mejor_longitud, "\n")
}
}
# Convertir índices de ruta a nombres de ciudades
nombres_ciudades <- colnames(distancias)
mejor_ruta_nombres <- nombres_ciudades[mejor_ruta]
# Mostrar resultados finales
cat("\nMejor ruta encontrada:\n")
cat(paste(mejor_ruta_nombres, collapse = " -> "), "->", mejor_ruta_nombres[1], "\n")
cat("Longitud total:", mejor_longitud, "\n")
# Algoritmo de Colonia de Hormigas para el Problema del Viajante usando datos de ciudades colombianas
# Cargar los datos
datos <- read.csv("costo_total.csv", row.names = 1)
# Convertir a matriz
distancias <- as.matrix(datos)
# Parámetros del algoritmo
num_ciudades <- nrow(distancias)
num_hormigas <- 20
max_iter <- 200
alpha <- 1       # Importancia de las feromonas
beta <- 2        # Importancia de la distancia (heurística)
rho <- 0.5       # Tasa de evaporación de feromonas
Q <- 100         # Constante para la actualización de feromonas
# Inicializar matriz de feromonas
feromonas <- matrix(1, num_ciudades, num_ciudades)
diag(feromonas) <- 0  # No hay feromonas en la diagonal (no se visita la misma ciudad)
# Función para calcular la probabilidad de selección de una ciudad
calcular_probabilidades <- function(ciudad_actual, visitadas, feromonas, distancias, alpha, beta) {
probabilidades <- rep(0, num_ciudades)
for (i in 1:num_ciudades) {
if (!(i %in% visitadas)) {
# Calcular la probabilidad según la fórmula del ACO
tau <- feromonas[ciudad_actual, i] ^ alpha
eta <- (1 / distancias[ciudad_actual, i]) ^ beta
probabilidades[i] <- tau * eta
}
}
# Normalizar para que la suma sea 1
if (sum(probabilidades) > 0) {
probabilidades <- probabilidades / sum(probabilidades)
}
return(probabilidades)
}
# Función para seleccionar la siguiente ciudad según las probabilidades
seleccionar_siguiente_ciudad <- function(probabilidades) {
ciudades <- 1:length(probabilidades)
siguiente <- sample(ciudades, 1, prob = probabilidades)
return(siguiente)
}
# Función para calcular la longitud de una ruta
calcular_longitud_ruta <- function(ruta, distancias) {
longitud <- 0
for (i in 1:(length(ruta) - 1)) {
longitud <- longitud + distancias[ruta[i], ruta[i+1]]
}
# Agregar el regreso a la ciudad inicial
longitud <- longitud + distancias[ruta[length(ruta)], ruta[1]]
return(longitud)
}
# Algoritmo principal de Colonia de Hormigas
mejor_ruta <- NULL
mejor_longitud <- Inf
historial_mejores <- numeric(max_iter)
set.seed(123)  # Para reproducibilidad
for (iter in 1:max_iter) {
# Matriz para almacenar la cantidad de feromonas a agregar
delta_feromonas <- matrix(0, num_ciudades, num_ciudades)
# Para cada hormiga
for (k in 1:num_hormigas) {
# Ciudad inicial aleatoria
ciudad_inicial <- sample(1:num_ciudades, 1)
ruta <- ciudad_inicial
visitadas <- ciudad_inicial
# Construir ruta completa
while (length(visitadas) < num_ciudades) {
ciudad_actual <- ruta[length(ruta)]
probabilidades <- calcular_probabilidades(ciudad_actual, visitadas, feromonas, distancias, alpha, beta)
siguiente_ciudad <- seleccionar_siguiente_ciudad(probabilidades)
ruta <- c(ruta, siguiente_ciudad)
visitadas <- c(visitadas, siguiente_ciudad)
}
# Calcular longitud de la ruta
longitud <- calcular_longitud_ruta(ruta, distancias)
# Actualizar la mejor ruta encontrada
if (longitud < mejor_longitud) {
mejor_ruta <- ruta
mejor_longitud <- longitud
}
# Actualizar la matriz de delta_feromonas
for (i in 1:(length(ruta) - 1)) {
delta_feromonas[ruta[i], ruta[i+1]] <- delta_feromonas[ruta[i], ruta[i+1]] + Q / longitud
delta_feromonas[ruta[i+1], ruta[i]] <- delta_feromonas[ruta[i+1], ruta[i]] + Q / longitud
}
# Agregar feromonas para el regreso a la ciudad inicial
delta_feromonas[ruta[length(ruta)], ruta[1]] <- delta_feromonas[ruta[length(ruta)], ruta[1]] + Q / longitud
delta_feromonas[ruta[1], ruta[length(ruta)]] <- delta_feromonas[ruta[1], ruta[length(ruta)]] + Q / longitud
}
# Evaporación de feromonas
feromonas <- (1 - rho) * feromonas
# Agregar nuevas feromonas
feromonas <- feromonas + delta_feromonas
# Almacenar la mejor longitud de esta iteración
historial_mejores[iter] <- mejor_longitud
# Mostrar progreso cada 10 iteraciones
if (iter %% 10 == 0) {
cat("Iteración", iter, "- Mejor longitud:", mejor_longitud, "\n")
}
}
# Convertir índices de ruta a nombres de ciudades
nombres_ciudades <- colnames(distancias)
mejor_ruta_nombres <- nombres_ciudades[mejor_ruta]
# Mostrar resultados finales
cat("\nMejor ruta encontrada:\n")
cat(paste(mejor_ruta_nombres, collapse = " -> "), "->", mejor_ruta_nombres[1], "\n")
cat("Longitud total:", mejor_longitud, "\n")
# Graficar la convergencia del algoritmo
plot(1:max_iter, historial_mejores, type = "l",
xlab = "Iteración", ylab = "Mejor longitud de ruta",
main = "Convergencia del Algoritmo de Colonia de Hormigas")
# Visualización de la ruta (si está instalado el paquete igraph)
if (requireNamespace("igraph", quietly = TRUE)) {
library(igraph)
# Crear un grafo completo
g <- make_full_graph(n = num_ciudades, directed = FALSE)
V(g)$name <- nombres_ciudades
# Definir los pesos de las aristas como las distancias
E(g)$weight <- 1
# Destacar las aristas de la mejor ruta
ruta_aristas <- c()
for (i in 1:(length(mejor_ruta) - 1)) {
ruta_aristas <- c(ruta_aristas,
get.edge.ids(g, c(mejor_ruta[i], mejor_ruta[i+1])))
}
# Agregar la arista de regreso a la ciudad inicial
ruta_aristas <- c(ruta_aristas,
get.edge.ids(g, c(mejor_ruta[length(mejor_ruta)], mejor_ruta[1])))
# Colores para las aristas
E(g)$color <- "gray"
E(g)$width <- 1
E(g)[ruta_aristas]$color <- "red"
E(g)[ruta_aristas]$width <- 3
# Visualizar
par(mar = c(0, 0, 2, 0))  # Ajustar márgenes
plot(g, layout = layout_with_fr,
main = "Mejor Ruta Encontrada",
vertex.color = "lightblue",
vertex.size = 10,
vertex.label.cex = 0.8,
edge.curved = 0.1)
}
